PDefs . Program ::= [Def] ;
separator nonempty Id "," ;
terminator Stm "" ;
terminator Def "" ;

comment "//" ;
comment "#" ;
comment "/*" "*/" ;

TypeDef . Def ::=  "typedef" Type Id ";";
TypeExp . Stm ::=  "typedef" Type Id ";";
UsingDef . Def ::=  "using" Type ";";
TypeDefInitA . Def ::= Type [Id] ";" ;
TypeDefInit . Def ::= Type [Id] "=" [P] ";" ;

DInline . Inline ::= "inline" ;
EmptyFun . EFun ::= Type Id "(" [ArgDef] ")" ;
DEmptyFunA . Def ::= Inline EFun ";" ;
DEmptyFun. Def ::= EFun ";" ;

-- Args
ADeclBaseWOIdDef . ArgDef ::= Arg ;
ADeclBaseWOId . ArgDef ::= T ;
separator ArgDef "," ;

ADeclBase . Arg ::= Type Id ;
ADeclBaseR . Arg ::= T Id;
ADecl . Arg ::= Arg "=" Exp ;
separator Arg "," ;

NonEmptyFun . NEmptyFun ::= EFun "{" [Stm] "}" ;
DIFun. Def ::= Inline NEmptyFun;
DFun. Def ::= NEmptyFun;

-- Structs
EStruct. Struct ::= "struct" Id "{" [Member] "}" ";";
SStruct. Stm ::= Struct;
DStruct. Def ::= Struct;

SMemberDecl . Member ::= Type Id ;
terminator Member ";" ;

-- Statements
SExp . Stm2 ::= Exp ";" ;
SE . P ::= Exp;
separator nonempty P "," ;
SInit . Stm ::= T [Id] "=" [P] ";" ;
SForBody . ForBody ::= "for" "(" Arg ";" Exp ";" Exp ")" ;
SFor . Stm ::= ForBody Exp ";" ;
SForWithBlock . Stm ::=  ForBody "{" [Stm] "}" ;
SReturn. Stm ::= "return" Exp ";" ;
SDo. Stm ::= "do" Stm "while" "(" Exp ")" ";" ;
SWhile. Stm ::= "while" "(" Exp ")" Stm ;
SBlock. Stm ::= "{" [Stm] "}" ;
SIfElse. Stm ::= "if" "(" Exp ")" Stm "else" Stm ;
SIf. Stm ::= "if" "(" Exp ")" Stm ;
SDecls . Stm ::= T [Id] ";" ;

coercions Stm 2 ;

separator nonempty Types "," ;
TypeListElem . Types ::= Type ;
QualifiedConstElemId . QualifiedConstElem ::= Id;
QualifiedConstElemInstance . QualifiedConstElem ::= Id "<" [Types] ">" ;

EQualifiedConst . Exp16 ::= QualifiedConst ;
QualifiedConstElems . QualifiedConst ::= [QualifiedConstElem] ;
separator nonempty QualifiedConstElem "::" ;

EString . Exp16 ::= [String] ;
terminator nonempty String "" ;

EDouble. Exp16 ::= Double ;
EInt . Exp16 ::= Integer ;
EChar. Exp16 ::= Char ;
ETrue. Exp16 ::= "true" ;
EFalse. Exp16 ::= "false" ;
EAddress. Exp16 ::= "&" Exp ;

EIndex. Exp15 ::= Exp15 "[" Exp "]" ;
ECall. Exp15 ::= Id "(" [Exp] ")" ;
EDot. Exp14 ::= Exp15 "." Exp14 ;
EArrow. Exp14 ::= Exp15 "->" Exp14 ;

EMod. Exp12 ::= Exp13 "%" Exp12 ;

ELShift. Exp10 ::= Exp11 "<<" Exp10 ;
ERShift. Exp10 ::= Exp11 ">>" Exp10 ;

EPostIncr.  Exp14  ::= Exp15 "++" ;
EPostDecr.  Exp14  ::= Exp15 "--" ;

EPreIncr.   Exp13  ::= "++" Exp14 ;
EPreDecr.   Exp13  ::= "--" Exp14 ;
EBoolNeg. Exp13 ::= "!" Exp ;
EIndirection. Exp13 ::= "*" Exp ;
ENeg. Exp13 ::= "-" Exp13 ;

ETimes.  Exp12  ::= Exp12 "*"  Exp13 ;
EDiv.    Exp12  ::= Exp12 "/"  Exp13 ;
EPlus.   Exp11  ::= Exp11 "+"  Exp12 ;
EMinus.  Exp11  ::= Exp11 "-"  Exp12 ;
ELt.     Exp9   ::= Exp10 "<"  Exp10 ;
EGt.     Exp9   ::= Exp10 ">"  Exp10 ;
ELtEq.   Exp9   ::= Exp10 "<=" Exp10 ;
EGtEq.   Exp9   ::= Exp10 ">=" Exp10 ;
EEq.     Exp8   ::= Exp9  "==" Exp9 ;
ENEq.    Exp8   ::= Exp9  "!=" Exp9 ;
EAnd.    Exp4   ::= Exp5  "&&" Exp4 ;
EOr.     Exp3   ::= Exp3  "||" Exp4 ;
EAss.    Exp2   ::= Exp3  "="  Exp2 ;
EAssAdd. Exp2 ::= Exp3 "+=" Exp2 ;
EAssSub. Exp2 ::= Exp3 "-=" Exp2 ;

ECond. Exp2 ::= Exp3 "?" Exp3 ":" Exp2 ;
EException. Exp1 ::= "throw" Exp ;

coercions Exp 16 ;
separator Exp "," ;

rules PType ::= "bool" | "int" | "double" | "void";
PTyp . Type ::= PType ;
QCns . Type ::= QualifiedConst;
TRef. Type ::= Type "&" ;
TConst . T ::= "const" Type ;
TConstE . T ::= Type ;

token Id (letter (letter | digit | '_')*) ;